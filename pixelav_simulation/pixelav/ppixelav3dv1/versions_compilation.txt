ppixelav versions:

ppixelav2_list_trkp_n_2f - reads a list of track angles, momenta, and flipped/unflipped orientation from track_list.txt as input.  The randomly generated midplane coordinates of the cluster are uniformly distributed over the single central pixel of the array.

ppixelav2_list_trkpy_n_2f - same as above but includes the local x,y hit coordinates on the module and the track pT.  These do not affect the cluster generation but are passed along as labels for ML training. The randomly generated midplane coordinates of the cluster are uniformly distributed over the central 3x3 pixel area of the array [the 3x3 area is very small as compared with the module dimensions so the actual coordinates on the array are effectively uncorrelated with the module coordinates].

ppixelav2_list_trkpy_n_2f_500 - same as above but with very fine time sampling to produce some test clusters for Doug Berry.

ppixelav2_rndm_trk_n_2f - generates clusters of random sizes distributed uniformly in the range (xmin,xmax) pixels along the beam axis, and (ymin,ymax) pixels transverse to it.  Note that xmin/xmax and ymin/ymax are signed quantities because the track angles are signed and the cluster sizes are not necessarily symmetric due Lorentz drift [xmin/xmax and ymin/ymax are geometrical only].  These parameters are specified in the file run.init which also includes a random number seed, an offset from the base run number defined in ppixel2.init, and the number of clusters per run.  There are two dummy numbers in run.init also.  The included run.init example file is labelled.

Compilation: the code compiles on x86-64, Apple silicon, and arm64 processors [and also on Apple powerpc but good luck finding one of those].  It uses vector quantities and vector instructions heavily which requires that appropriate compiler switches be set. The sample linkxxx_yyy scripts contain compile instructions that have been tested with various compilers [they need to be tailored to compiler locations/libraries of your installation].  Note that the icc compiler generates the fastest code on x86-64 cpus.  Unfortunately intel has decided to remove it from their suite of developer tools (which are free).  They recommend switching to the newer icx compiler which produces code that is 11% slower.  The AMD aocc compiler also produces code that is 11% slower [tested on AMD cpus, the intel suite works on intel and AMD chips].  Unfortunately, gcc generates code that is ~40% slower than icc on x86-64 processors.  gcc/clang is available on Apple silicon and the combination of hardware/software runs 50-70% faster than x86-64/icc.  The same compilation instruction works on ARM-NEON processors.  Recent tests with a new raspberry pi5 run about 50% slower than x86-64/icc.

